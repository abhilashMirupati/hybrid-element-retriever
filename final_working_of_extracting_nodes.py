# -*- coding: utf-8 -*-
"""Final Working of Extracting nodes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13UyxbHUwl_8GmRUp--XrFPWx-cwrCjQ8
"""



from transformers import MarkupLMProcessor, MarkupLMForQuestionAnswering ,AutoProcessor, AutoModelForQuestionAnswering
import torch

from playwright.sync_api import sync_playwright
from lxml import etree, html
import asyncio
from playwright.async_api import async_playwright

import nest_asyncio
nest_asyncio.apply()

# ------------------- Initialize Model -------------------
model_name = "microsoft/markuplm-large-finetuned-websrc"
processor = AutoProcessor.from_pretrained("microsoft/markuplm-large-finetuned-websrc")
model = AutoModelForQuestionAnswering.from_pretrained("microsoft/markuplm-large-finetuned-websrc")
model.eval()

# ----------------- Async extractor (core) -----------------
async def _extract_candidate_snippets_async(url: str, target_text: str, ancestor_levels: int = 2, max_siblings: int = 0, timeout: int = 30000):
    """
    Returns a list of HTML snippet strings. Each snippet contains:
      - a reconstructed ancestor chain up to `ancestor_levels` (each ancestor's tag+attrs are preserved)
      - only the path to the matching node (no extra siblings) unless max_siblings > 0
      - optional sibling block (when max_siblings > 0)
    Exact match on element.innerText (trimmed) and case-sensitive.
    Filters for elements that are truly hidden (not just off-screen).
    """
    snippets = []
    matching_nodes_info = []
    async with async_playwright() as pw:
        browser = await pw.chromium.launch(headless=True)
        page = await browser.new_page()
        await page.goto(url, wait_until="networkidle", timeout=timeout)

        # Try to request a deep CDP snapshot (best-effort). If unavailable, still continue with page.evaluate.
        try:
            cdp = await page.context.new_cdp_session(page)
            try:
                await cdp.send("DOM.getFlattenedDocument", {"depth": -1, "pierce": True})
            except Exception:
                try:
                    await cdp.send("DOM.getDocument", {"depth": -1, "pierce": True})
                except Exception:
                    pass
        except Exception:
            pass

        # JS function builds snippet strings by reconstructing an ancestor chain
        js = r"""
        (args) => {
            const targetText = args.targetText;
            const ancestorLevels = Number(args.ancestorLevels) || 1;
            const maxSiblings = Number(args.maxSiblings) || 0;
            const out = [];
            const matchingNodesInfo = [];
            const processedNodes = new Set();

            function isElementTrulyHidden(el) {
                if (!el) return true;
                try {
                    const rect = el.getBoundingClientRect();
                    if ((rect.width === 0 && rect.height === 0)) return true;
                    const style = window.getComputedStyle(el);
                    if (style.display === 'none' || style.visibility === 'hidden' || style.opacity === '0') return true;
                    let parent = el.parentElement;
                    while (parent && parent !== document.documentElement) {
                        const pstyle = window.getComputedStyle(parent);
                        if (pstyle.display === 'none' || pstyle.visibility === 'hidden' || pstyle.opacity === '0') return true;
                        parent = parent.parentElement;
                    }
                } catch (e) {
                    return true;
                }
                return false;
            }

            function isElementInViewport(el) {
              if (!el) return false;
              const rect = el.getBoundingClientRect();
              return (
                rect.top >= 0 &&
                rect.left >= 0 &&
                rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                rect.right <= (window.innerWidth || document.documentElement.clientWidth)
              );
            }

            function escapeAttrVal(v) {
                return String(v).replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            }

            function openingTagFor(el) {
                if (!el || el.nodeType !== 1) return '';
                const tag = el.tagName.toLowerCase();
                const attrs = [];
                for (let i = 0; i < el.attributes.length; i++) {
                    const a = el.attributes[i];
                    // preserve boolean attributes too (value may be "")
                    attrs.push(`${a.name}="${escapeAttrVal(a.value)}"`);
                }
                return `<${tag}${attrs.length ? ' ' + attrs.join(' ') : ''}>`;
            }

            // build a path from some ancestor down to primaryNode, reconstructing only the path content
            function buildAncestorPathSnippet(primaryNode, levelsUp) {
                // collect ancestors (excluding documentElement)
                const ancestors = [];
                let cur = primaryNode;
                while (cur && cur !== document.documentElement) {
                    ancestors.unshift(cur); // we'll reverse later so that topmost ancestor is first
                    cur = cur.parentElement;
                }
                // ancestors now from topmost parent (closest to documentElement) down to primaryNode
                // we want last `levelsUp` ancestors (counting the primaryNode as level 0)
                const total = ancestors.length;
                const startIndex = Math.max(0, total - (levelsUp + 1)); // include primaryNode
                const slice = ancestors.slice(startIndex); // from chosen ancestor down to primaryNode

                // build nested HTML: open tags for each ancestor (except primaryNode), then primaryNode.outerHTML, then closing tags
                let html = '';
                for (let i = 0; i < slice.length - 1; i++) { // open tags for all but the primary node
                    html += openingTagFor(slice[i]);
                }
                // primary node is the last item
                const primary = slice[slice.length - 1];
                html += primary.outerHTML;
                // close tags in reverse order for the opened ancestors
                for (let i = slice.length - 2; i >= 0; i--) {
                    html += `</${slice[i].tagName.toLowerCase()}>`;
                }
                return html;
            }

            const walker = document.createTreeWalker(document.documentElement, NodeFilter.SHOW_ELEMENT, null, false);
            let node;
            while (node = walker.nextNode()) {
                if (processedNodes.has(node)) continue;

                // skip if any ancestor already processed
                let cur = node;
                let skip = false;
                while (cur && cur !== document.documentElement) {
                    if (processedNodes.has(cur)) { skip = true; break; }
                    cur = cur.parentElement;
                }
                if (skip) continue;

                try {
                    const txt = (node.innerText || '').trim();
                    if (txt === targetText) {
                        // find primary node (parent priority logic preserved)
                        let parent = node.parentElement;
                        let primaryNode = node;
                        while (parent && parent !== document.documentElement) {
                            if ((parent.innerText || '').trim() === targetText) {
                                primaryNode = parent;
                                break;
                            }
                            if (['A','BUTTON'].includes(parent.tagName) && (parent.innerText || '').trim().includes(targetText)) {
                                primaryNode = parent;
                                break;
                            }
                            parent = parent.parentElement;
                        }

                        // mark subtree of the original node as processed (avoid duplicate nested matches)
                        try {
                            const subWalker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, null, false);
                            let sub;
                            while (sub = subWalker.nextNode()) {
                                processedNodes.add(sub);
                            }
                        } catch(e) { /* ignore */ }
                        processedNodes.add(primaryNode);

                        if (isElementTrulyHidden(primaryNode)) continue;

                        // collect simple info
                        matchingNodesInfo.push({
                            tagName: primaryNode.tagName,
                            innerText: (primaryNode.innerText || '').trim(),
                            outerHTMLPreview: (primaryNode.outerHTML || '').substring(0,200) + (primaryNode.outerHTML.length > 200 ? '...' : ''),
                            isVisible: isElementInViewport(primaryNode)
                        });

                        // Build ancestor chain snippet (reconstructed)
                        const ancestorChainHtml = buildAncestorPathSnippet(primaryNode, ancestorLevels);

                        // Build sibling block if requested
                        let siblingBlock = '';
                        if (maxSiblings > 0) {
                            const prev = [];
                            const next = [];
                            let p = primaryNode.previousElementSibling;
                            let n = primaryNode.nextElementSibling;
                            let cnt = 0;
                            while (p && cnt < maxSiblings) { prev.unshift(p.outerHTML); p = p.previousElementSibling; cnt++; }
                            cnt = 0;
                            while (n && cnt < maxSiblings) { next.push(n.outerHTML); n = n.nextElementSibling; cnt++; }
                            if (prev.length || next.length) {
                                siblingBlock = '<div class="her-snippet-siblings">' + prev.join('') + next.join('') + '</div>';
                            }
                        }

                        // decode helper
                        function htmlDecode(input) {
                          if (!input) return '';
                          const t = document.createElement('textarea');
                          t.innerHTML = input;
                          return t.value;
                        }

                        function splitCamelCase(s) { return String(s || '').replace(/([a-z0-9])([A-Z])/g, '$1 $2'); }

                        // build meta parts from attributes & parent text
                        let metaParts = [];
                        try {
                          const p = primaryNode;
                          metaParts.push(p.getAttribute && (p.getAttribute('aria-label') || '') || '');
                          metaParts.push(p.getAttribute && (p.getAttribute('label') || '') || '');
                          metaParts.push(p.getAttribute && (p.getAttribute('role') || '') || '');
                          metaParts.push(p.id || '');
                          metaParts.push(p.className || '');
                          const rawDataTrack = p.getAttribute && (p.getAttribute('data-track') || '') || '';
                          const decodedDataTrack = htmlDecode(rawDataTrack);
                          metaParts.push(decodedDataTrack);
                          if (p.parentElement) metaParts.push(p.parentElement.innerText || '');
                        } catch(e) { /* ignore */ }

                        const metaText = metaParts.filter(Boolean).map(x => String(x).trim()).join(' ');
                        const metaTextNormalized = splitCamelCase(metaText);
                        const metaDiv = metaTextNormalized ? `<div class="her-snippet-meta" aria-hidden="true">${metaTextNormalized}</div>` : '';
                        const snippet = '<div class="her-snippet-wrapper">' + ancestorChainHtml + siblingBlock + metaDiv + '</div>';
                        out.push(snippet);
                    }
                } catch (e) {
                    // ignore node errors
                }
            }

            return { snippets: out, matchingNodesInfo: matchingNodesInfo };
        }
        """

        extracted_data = await page.evaluate(js, {
            'targetText': target_text,
            'ancestorLevels': ancestor_levels,
            'maxSiblings': max_siblings
        })
        await browser.close()

        # ensure unique snippets and preserve order
        seen_snippets = set()
        for s in extracted_data['snippets']:
            if s and s not in seen_snippets:
                snippets.append(s)
                seen_snippets.add(s)

        matching_nodes_info = extracted_data['matchingNodesInfo']

    return snippets, matching_nodes_info


# ----------------- Sync wrapper -----------------
def extract_candidate_snippets(url: str, target_text: str, ancestor_levels: int = 1, max_siblings: int = 0, timeout: int = 30000):
    return asyncio.get_event_loop().run_until_complete(
        _extract_candidate_snippets_async(url, target_text, ancestor_levels, max_siblings, timeout)
    )

# ----------------- Example: how to plug into your downstream scorer -----------------
# Replace url/target_text as desired
url = "https://www.verizon.com/smartphones/"
target_text = "Apple"   # exact case-sensitive match

# This produces `candidates`, a list of HTML snippet strings you can pass directly to your scoring code:
candidates, matching_nodes_info = extract_candidate_snippets(url, target_text, ancestor_levels=2, max_siblings=0)

print(f"Extracted {len(candidates)} candidate snippet(s).")
for i, c in enumerate(candidates):
    print(f"\n--- Candidate {i} ---\n{c}\n") # Display full snippet


print(f"\n--- Info about {len(matching_nodes_info)} matching nodes ---")
for i, node_info in enumerate(matching_nodes_info):
    print(f"Node {i}:")
    print(f"  Tag Name: {node_info['tagName']}")
    print(f"  InnerText: {node_info['innerText']}")
    print(f"  Is Visible: {node_info['isVisible']}") # This now uses the viewport check for info display
    print(f"  OuterHTML (partial): {node_info['outerHTMLPreview']}\n")

def score_snippets(candidates, query, debug=False):
    results = []
    for idx, snippet in enumerate(candidates):
        # Encode
        inputs = processor(
            questions=query, 
            html_strings=[snippet],
            return_tensors="pt",
            truncation=True,
            padding=True,
            max_length=512
        )
        with torch.no_grad():
            outputs = model(**inputs)

        start_logits = outputs.start_logits[0]
        end_logits = outputs.end_logits[0]

        # -------- Pure span-based scoring (no heuristics) --------
        best_score = float("-inf")
        best_i, best_j = 0, 0
        for i in range(len(start_logits)):
            for j in range(i, len(end_logits)):
                score = start_logits[i].item() + end_logits[j].item()
                if score > best_score:
                    best_score = score
                    best_i, best_j = i, j

        # decode best span text for debug
        tokens = processor.tokenizer.convert_ids_to_tokens(inputs["input_ids"][0])
        best_span_tokens = tokens[best_i: best_j + 1]
        best_span_text = processor.tokenizer.convert_tokens_to_string(best_span_tokens)

        if debug:
            print(f"\nCandidate {idx}:")
            print(f"  Best score: {best_score:.2f}")
            print(f"  Best span text: {best_span_text}")

        results.append((best_score, snippet, {
            "best_i": best_i,
            "best_j": best_j,
            "best_span_text": best_span_text
        }))

    # Sort by score (descending)
    results.sort(key=lambda x: x[0], reverse=True)
    return results

# ------------------- User query -------------------
query = 'Click on Apple filter button'


# ------------------- Run and print -------------------
results = score_snippets(candidates, query, debug=False)

for idx, (score, snippet, meta) in enumerate(results):
    print(f"\nCandidate {idx} | Score: {score:.2f}")
    print(f"Best span text: {meta['best_span_text']}")
    print(snippet)
    print("-" * 80)